package tex;

import generator.tex.*;
import haxe.io.Path;
import sys.FileSystem;
import sys.io.File;
import transform.Document;
import transform.Context;
import util.sys.FsUtil;

import Assertion.*;

using Literals;
using StringTools;
using PositionTools;

class Generator {
	static var FILE_BANNER = '
	% DO NOT EDIT THIS FILE MANUALLY!
	%
	% This file has been automatically generated from manuscript sources
	% using the *manu* tool:
	%  tool version: ${Main.version.commit}
	%  haxe version: ${Main.version.haxe}
	%  runtime: ${Main.version.runtime}
	%  platform: ${Main.version.platform}
	%
	% ${Main.LOGO}   ${Main.LOGO_TEXT}
	'.doctrim();  // TODO runtime version, sources version

	var hasher:AssetHasher;
	var destDir:String;
	var preamble:StringBuf;
	var bufs:Map<String,StringBuf>;
	var index:Map<String,DElem>;

	static var texEscapes = ~/([{}\$&#\^_%~])/g;  // FIXME complete with LaTeX/Math

	static inline var ASSET_SUBDIR = "assets";

	function _saveAsset(at:Array<String>, src:String, size:BlobSize):String
	{
		var sdir =
			switch size {
			case MarginWidth: "mw";
			case TextWidth: "tw";
			case FullWidth: "fw";
			}
		var ldir = Path.join([ASSET_SUBDIR, sdir]);
		var dir = Path.join([destDir, ldir]);
		if (!FileSystem.exists(dir))
			FileSystem.createDirectory(dir);

		var ext = Path.extension(src).toLowerCase();
		var data = File.getBytes(src);
		var hash = hasher.hash(src, data);

		// TODO question: is the extension even neccessary?
		var name = ext != "" ? hash + "." + ext : hash;
		var dst = Path.join([dir, name]);
		File.saveBytes(dst, data);

		var lpath = Path.join([ldir, name]);
		if (~/windows/i.match(Sys.systemName()))
			lpath = lpath.replace("\\", "/");
		assert(lpath.indexOf(" ") < 0, lpath, "spaces are toxic in TeX paths");
		assert(lpath.indexOf(".") == lpath.lastIndexOf("."), lpath, "unprotected dots are toxic in TeX paths");
		weakAssert(!Path.isAbsolute(lpath), "absolute paths might be toxic in TeX paths");
		weakAssert(~/[a-z\/-]+/.match(lpath), lpath, "weird chars are dangerous in TeX paths");
		return lpath;
	}

	function saveAsset(at, src, size)
		return Context.time("tex generation (saveAsset)", _saveAsset.bind(at, src, size));

	public function gent(text:String, preserveSlashes=false)
	{
		return text.split("\\").map(
			function (safe) {
				var part = texEscapes.replace(safe, "\\$1");  // assumes texEscapes has 'g' flag
				if (preserveSlashes)
					return part;
				return part.replace("/", "\\slash\\hspace{0pt}");
			}
		).join("\\textbackslash{}");
	}

	public function genp(pos:Position)
	{
		if (Context.texNoPositions)
			return "";
		if (Context.debug) {
			var lpos = pos.toLinePosition();
			return '% @ ${lpos.src}: lines ${lpos.lines.min + 1}-${lpos.lines.max}: code points ${lpos.codes.min + 1}-${lpos.codes.max}\n';  // TODO slow, be careful!
		}
		return '% @ ${pos.src}: bytes ${pos.min + 1}-${pos.max}\n';
	}

	function resolveRef(type:RefType, id:Elem<String>)
	{
		var targetElem = index[id.def];
		assert(targetElem != null, "could not resolve reference", id.def, id.pos.toString());
		var infos = getFirstPassInfos(targetElem);
		var prefix = null;
		var text = switch [type, targetElem.def] {
		case [_, DTitle(_)|DList(_)|DCodeBlock(_)|DQuotation(_)|DParagraph(_)|DElemList(_)|DEmpty|
				DHtmlStore(_)|DHtmlToHead(_)|DLaTeXPreamble(_)|DLaTeXExport(_)]:
			assert(false, "unsupported target", Type.enumConstructor(targetElem.def), id.pos.toString()); null;
		case [RTAuto|RTItemName, DVolume(no,name,_)|DChapter(no,name,_)]:
			'${gent(Std.string(no))} (${genh(name)})';
		case [RTItemName, DSection(no,name,_)|DSubSection(no,name,_)|DSubSubSection(no,name,_)|
				DBox(no,name,_)|DFigure(no,_,_,name,_)|DTable(no,_,name,_,_)|DImgTable(no,_,name,_)]:
			'${gent(infos.no)} (${genh(name)})';
		case [RTAuto|RTItemNumber, _]:
			gent('${infos.no}');
		case [RTPageNumber, _]:
			prefix = "page ";
			'\\pageref{${infos.id}}';
		}
		if (prefix == null)
		 prefix = gent(Type.enumConstructor(targetElem.def).substr(1).replace("SubS", "Sub-S").replace("Img", "")) + " ";
		return { targetElem:targetElem, infos:infos, text:text, prefix:prefix };
	}

	function compareCounters(a:String, b:String):Int
	{
		var a = a.split(".");
		var b = b.split(".");
		assert(a.length == b.length && a.length <= 3, a.length, b.length);
		for (i in 0...a.length) {
			if (a[i] != b[i])
				return (Std.parseInt(a[i]) - Std.parseInt(b[i])) << 10*(a.length - i - 1);
		}
		return 0;
	}

	public function genh(h:HElem)
	{
		switch h.def {
		case Wordspace:
			return " ";
		case Superscript(h):
			return '\\textsuperscript{${genh(h)}}';
		case Subscript(h):
			return '\\textsubscript{${genh(h)}}';
		case Emphasis(h):
			return '\\emphasis{${genh(h)}}';
		case Highlight(h):
			return '\\highlight{${genh(h)}}';
		case Word(word):
			return gent(word);
		case InlineCode(code):
			return '\\code{${gent(code)}}';
		case Math(tex):
			return '\\($tex\\)';
		case Url(address):
			return '\\url{${gent(address, true)}}';
		case Ref(type, target):
			var ref = resolveRef(type, target);
			return '\\hyperref[${ref.infos.id}]{${ref.prefix}${ref.text}}';
		case RangeRef(type, firstTarget, lastTarget):
			/*
			Be user friendly: handle first == last, check if targets match in type
			and fix order if first > last.  Additionally, customize the interval word
			if last = first + 1.
			*/
			var first = resolveRef(type, firstTarget);
			var last = resolveRef(type, lastTarget);
			assert(first.targetElem.def.getIndex() == last.targetElem.def.getIndex(),
					"trying to reference a range of different elements",
					first.targetElem.def.getName(), last.targetElem.def.getName(), h.pos.toString());
			assert(first.prefix == last.prefix);
			if (first.text == last.text)  // infos.url theoretically better, but text practically more relevant
				return genh({ def:Ref(type, firstTarget), pos:h.pos });
			var dif = compareCounters(last.infos.no, first.infos.no);
			if (dif < 0) {
				var tmp = first;
				first = last;
				last = tmp;
				dif = - dif;
			}
			var interval = dif == 1 ? " and " : " to ";
			var prefix = first.prefix;
			if (prefix != "")
				prefix = prefix.rtrim() + "s ";
			return '$prefix\\hyperref[${first.infos.id}]{${first.text}}$interval\\hyperref[${last.infos.id}]{${last.text}}';
		case HElemList(li):
			var buf = new StringBuf();
			for (i in li)
				buf.add(genh(i));
			return buf.toString();
		case HEmpty:
			return "";
		}
	}

	static function normalizeId(ctx:IdCtx, id:String):String
	{
		var ctx:IdCtx = Reflect.copy(ctx);
		var segs = id.split(":");
		assert(segs.length > 0 && segs.length % 2 == 0, segs.length, id);
		var parts = [ for (i in 0...(segs.length >> 1)) { name:segs[i*2], value:segs[i*2 + 1] } ];
		// TODO check parts
		// TODO sort parts
		for (p in parts)
			Reflect.setProperty(ctx, p.name, p.value);
		return
				switch parts[parts.length - 1].name {
				case "volume": ctx.join(true, ":", volume);
				case "chapter": ctx.join(true, ":", chapter);
				case "section": ctx.join(true, ":", chapter, section);
				case "subSection": ctx.join(true, ":", chapter, section, subSection);
				case "subSubSection": ctx.join(true, ":", chapter, section, subSection, subSubSection);
				case "box": ctx.join(true, ":", chapter, box);
				case "figure": ctx.join(true, ":", chapter, figure);
				case "table": ctx.join(true, ":", chapter, table);
				case other: assert(false, other); null;
				}
	}

	static function normalizeRefs(ctx:IdCtx, h:HElem)
	{
		switch h.def {
		case Ref(type, target):
			h.def = parser.Ast.HDef.Ref(type, { def:normalizeId(ctx, target.def), pos:target.pos });
		case RangeRef(type, firstTarget, lastTarget):
			h.def = parser.Ast.HDef.RangeRef(type, { def:normalizeId(ctx, firstTarget.def), pos:firstTarget.pos },
					{ def:normalizeId(ctx, lastTarget.def), pos:lastTarget.pos });
		case HElemList(li):
			for (i in li)
				normalizeRefs(ctx, i);
		case _:
			// noop
		}
	}

	function firstPass(v:DElem, idc:IdCtx, noc:NoCtx)
	{
		var infos:{ id:String, no:String } = null;
		switch v.def {
		case DVolume(no, name, children):
			idc.volume = v.id.sure();
			noc.volume = no;
			infos = {
				id : idc.join(true, ":", volume),
				no : noc.join(false, ".", volume)
			};
			normalizeRefs(idc, name);
			firstPass(children, idc, noc);
		case DChapter(no, name, children):
			idc.chapter = v.id.sure();
			noc.chapter = no;
			infos = {
				id : idc.join(true, ":", chapter),
				no : noc.join(false, ".", chapter)
			};
			normalizeRefs(idc, name);
			firstPass(children, idc, noc);
		case DSection(no, name, children):
			idc.section = v.id.sure();
			noc.section = no;
			infos = {
				id : idc.join(true, ":", chapter, section),
				no : noc.join(false, ".", chapter, section)
			};
			normalizeRefs(idc, name);
			firstPass(children, idc, noc);
		case DSubSection(no, name, children):
			idc.subSection = v.id.sure();
			noc.subSection = no;
			infos = {
				id : idc.join(true, ":", chapter, section, subSection),
				no : noc.join(false, ".", chapter, section, subSection)
			};
			normalizeRefs(idc, name);
			firstPass(children, idc, noc);
		case DSubSubSection(no, name, children):
			idc.subSubSection = v.id.sure();
			noc.subSubSection = no;
			infos = {
				id : idc.join(true, ":", chapter, section, subSection, subSubSection),
				no:noc.join(false, ".", chapter, section, subSection, subSubSection)
			};
			normalizeRefs(idc, name);
			firstPass(children, idc, noc);
		case DBox(no, name, children):
			idc.box = v.id.sure();
			noc.box = no;
			infos = {
				id : idc.join(true, ":", chapter, box),
				no : noc.join(false, ".", chapter, box)
			};
			normalizeRefs(idc, name);
			firstPass(children, idc, noc);
		case DFigure(no, _, _, caption, cright):
			idc.figure = v.id.sure();
			noc.figure = no;
			infos = {
				id : idc.join(true, ":", chapter, figure),
				no : noc.join(false, ".", chapter, figure)
			};
			normalizeRefs(idc, caption);
			normalizeRefs(idc, cright);
		case DTable(no, _, title, header, rows):
			idc.table = v.id.sure();
			noc.table = no;
			infos = {
				id : idc.join(true, ":", chapter, table),
				no : noc.join(false, ".", chapter, table)
			};
			normalizeRefs(idc, title);
			for (i in header)
				firstPass(i, idc, noc);
			for (row in rows) {
				for (i in row)
					firstPass(i, idc, noc);
			}
		case DImgTable(no, _, title, _):
			idc.table = v.id.sure();
			noc.table = no;
			infos = {
				id : idc.join(true, ":", chapter, table),
				no : noc.join(false, ".", chapter, table)
			};
			normalizeRefs(idc, title);
		case DElemList(li), DList(_, li):
			for (i in li)
				firstPass(i, idc, noc);
			return;
		case DParagraph(content):
			normalizeRefs(idc, content);
			return;
		case DQuotation(content, author):
			normalizeRefs(idc, content);
			normalizeRefs(idc, author);
			return;
		case DTitle(title):
			normalizeRefs(idc, title);
			return;
		case DEmpty, DCodeBlock(_), DHtmlStore(_), DHtmlToHead(_), DLaTeXExport(_), DLaTeXPreamble(_):
			return;
		}
		assert(infos != null, v.pos.toString());
		weakAssert(!index.exists(infos.id), "global id conflict", infos.id, v.pos.toString());  // FIXME switch to assert
		index[infos.id] = v;
		Reflect.setField(v, "_first", infos);
	}

	static function getFirstPassInfos(v:DElem):{ id:String, no:String }
	{
		var infos = Reflect.field(v, "_first");
		assert(infos != null, v.pos.toString());
		return infos;
	}

	public function genv(v:DElem, at:Array<String>)
	{
		assert(!Lambda.foreach(at, function (p) return p.endsWith(".tex")), at, "should not be anything but a directory");
		switch v.def {
		case DHtmlStore(_), DHtmlToHead(_):
			return "";
		case DLaTeXPreamble(_.toInputPath() => path):
			// TODO validate path (or has Transform done so?)
			preamble.add('% included from `$path`\n');
			preamble.add(genp(v.pos));
			preamble.add(File.getContent(path).trim());
			preamble.add("\n\n");
			return "";
		case DLaTeXExport(_.toInputPath() => src, _.toOutputPath(destDir) => dest):
			assert(FileSystem.isDirectory(destDir));
			FsUtil.copy(src, dest, false);
			return "";
		case DVolume(no, name, children):
			var infos = getFirstPassInfos(v);
			var path = Path.join(at.concat([v.id.sure()+".tex"]));
			var dir = at.concat([v.id.sure()]);
			var buf = new StringBuf();
			bufs[path] = buf;
			buf.add("% This file is part of the\n");
			buf.add(FILE_BANNER);
			buf.add('\n\n\\volume{$no}{${genh(name)}}\n\\label{${infos.id}}\n${genp(v.pos)}\n${genv(children, dir)}');
			return '\\input{$path}\n\n';
		case DChapter(no, name, children):
			var infos = getFirstPassInfos(v);
			var path = Path.join(at.concat([v.id.sure()+".tex"]));
			var buf = new StringBuf();
			bufs[path] = buf;
			buf.add("% This file is part of the\n");
			buf.add(FILE_BANNER);
			buf.add('\n\n\\chapter{$no}{${genh(name)}}\n\\label{${infos.id}}\n${genp(v.pos)}\n${genv(children, at)}');
			return '\\input{$path}\n\n';
		case DSection(no, name, children):
			var infos = getFirstPassInfos(v);
			return '\\section{$no}{${genh(name)}}\n\\label{${infos.id}}\n${genp(v.pos)}\n${genv(children, at)}';
		case DSubSection(no, name, children):
			var infos = getFirstPassInfos(v);
			return '\\subsection{$no}{${genh(name)}}\n\\label{${infos.id}}\n${genp(v.pos)}\n${genv(children, at)}';
		case DSubSubSection(no, name, children):
			var infos = getFirstPassInfos(v);
			return '\\subsubsection{$no}{${genh(name)}}\n\\label{${infos.id}}\n${genp(v.pos)}\n${genv(children, at)}';
		case DBox(no, name, children):
			var infos = getFirstPassInfos(v);
			return '\\beginbox{$no}{${genh(name)}}\n\\label{${infos.id}}\n${genv(children, at)}\\endbox\n${genp(v.pos)}\n';
		case DTitle(name):
			// FIXME optional id
			return '\\manutitle{${genh(name)}}\n${genp(v.pos)}\n';
		case DFigure(no, size, _.toInputPath() => path, caption, cright):
			var infos = getFirstPassInfos(v);
			path = saveAsset(at, path, size);
			var csize =
				switch size {
				case MarginWidth: "small";
				case TextWidth: "medium";
				case FullWidth: "large";
				}
			// FIXME label
			return '\\manu${csize}figure{$path}{$no}{${genh(caption)}\\label{${infos.id}}}{${genh(cright)}}\n${genp(v.pos)}\n';
		case DTable(_):
			var infos = getFirstPassInfos(v);
			return LargeTable.gen(v, infos.id, this, at);
		case DImgTable(no, size, caption, _.toInputPath() => path):
			var infos = getFirstPassInfos(v);
			path = saveAsset(at, path, size);
			var csize =
				switch size {
				case MarginWidth: "small";
				case TextWidth: "medium";
				case FullWidth: "large";
				}
			// FIXME label
			return '\\manu${csize}imgtable{$path}{$no}{${genh(caption)}\\label{${infos.id}}}\n${genp(v.pos)}\n';
		case DList(numbered, li):
			var buf = new StringBuf();
			var env = numbered ? "enumerate" : "itemize";
			buf.add('\\begin{$env}\n');
			for (i in li)
				switch i.def {
				case DParagraph(h):
					buf.add('\\item ${genh(h)}${genp(i.pos)}');
				case _:
					buf.add('\\item {${genv(i, at)}}\n');
				}
			buf.add('\\end{$env}\n');
			buf.add(genp(v.pos));
			buf.add("\n");
			return buf.toString();
		case DCodeBlock(code):
			show("code blocks in TeX improperly implemented");
			return '\\begincode\n${gent(code)}\n\\endcode\n${genp(v.pos)}\n';
		case DQuotation(text, by):
			return '\\quotation{${genh(text)}}{${genh(by)}}\n${genp(v.pos)}\n';
		case DParagraph({pos:p, def:Math(tex)}):
			return '\\[$tex\\]';
		case DParagraph(h):
			return '${genh(h)}\\par\n${genp(v.pos)}\n';
		case DElemList(li):
			var buf = new StringBuf();
			for (i in li)
				buf.add(genv(i, at));
			return buf.toString();
		case DEmpty:
			return "";
		}
	}

	public function writeDocument(doc:Document)
	{
		bufs = new Map();
		index = new Map();

		FileSystem.createDirectory(destDir);
		preamble = new StringBuf();
		preamble.add(FILE_BANNER);
		preamble.add("\n\n");

		firstPass(doc, new IdCtx(), new NoCtx());
		var contents = genv(doc, ["./"]);

		var root = new StringBuf();
		root.add(preamble.toString());
		root.add("\\begin{document}\n\n");
		root.add(contents);
		root.add("\\end{document}\n");
		bufs["book.tex"] = root;

		for (p in bufs.keys()) {
			var path = Path.join([destDir, p]);
			FileSystem.createDirectory(Path.directory(path));
			File.saveContent(path, bufs[p].toString());
		}
	}

	public function new(hasher, destDir)
	{
		this.hasher = hasher;
		// TODO validate destDir
		this.destDir = destDir;
	}
}

